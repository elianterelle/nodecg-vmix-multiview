"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConnectionTCP = void 0;
const net_1 = require("net");
const querystring_1 = __importDefault(require("querystring"));
// Custom Exceptions
const api_url_error_1 = __importDefault(require("../exceptions/api-url-error"));
/**
 * Base socket listener types
 */
const SOCKET_BASE_LISTENER_TYPES = [
    'close',
    'connect',
    'drain',
    'end',
    'error',
    'lookup',
    'ready',
    'timeout'
];
// "Custom" types of messages from vMix
const CUSTOM_MESSAGES_TYPES = [
    'tally',
    'acts',
    'version', // vMix version info
];
const CUSTOM_LISTENER_TYPES = [
    'connecting',
    'data',
    // 'disconnect',
    'xml',
    ...CUSTOM_MESSAGES_TYPES
];
/**
 * Default hostname of vMix instance
 * When nothing passed to connection class-instance
 */
const DEFAULT_HOST = 'localhost';
/**
 * Default port used by vMix to serve TCP connections is 8099
 * But it can be other port if the connection is through a firewall
 */
const DEFAULT_TCP_PORT = 8099;
/**
 * Length in bytes of CRLF (New Line character on Microsoft Windows) "\r\n"
 */
const NEWLINE_CHAR_BYTE_LENGTH = 2;
/**
 * vMix Connection via TCP
 *
 */
// vMix TCP API docs
// https://www.vmix.com/help24/TCPAPI.html
//
// Internally using NodeJS Net Socket
// https://nodejs.org/api/net.html#net_new_net_socket_options
//
// With inspiration from: Github Gist: Node.js TCP client / server
// https://gist.github.com/sid24rane/2b10b8f4b2f814bd0851d861d3515a10
class ConnectionTCP {
    /**
     * Constructor
     *
     * @param {string} host
     * @param {object} optionss
     */
    constructor(host = DEFAULT_HOST, options = {}) {
        // Guard passed options of wrong type
        // if (!options || typeof options !== 'object') {
        //     options = {}
        // }
        this._host = DEFAULT_HOST;
        this._port = DEFAULT_TCP_PORT;
        // Buffer to store byte array of currently incoming messages
        this._buffer = Buffer.from([]);
        /**
         * Node TCP socket client to vMix instance
         */
        this._socket = new net_1.Socket();
        /**
         * All listeners
         */
        this._listeners = {};
        // Auto reconnect? Enabled by default
        this._autoReconnect = true;
        this._isRetrying = false;
        this._reconnectionIntervalTimeout = 10000;
        this._reconnectionInterval = null;
        // // Timeout for establishing the connection. Should be smaller than the reconnect invterval!
        // protected _connectTimeoutDuration: number = 5000
        // protected _connectTimeout: NodeJS.Timeout | null = null
        /**
         * Emit vMix messages to listeners registered for data
         * as a fallback solution if no listener is registered
         * in the specific custom-listener-type
         *
         * Enabled by default
         */
        this._useDataListenersAsFallback = true;
        /*
         * Print debug messages
         *
         * Disabled by default
         */
        this._debug = false;
        /**
         * Print debug messages regarding buffer
         *
         * Disabled by default
         */
        this._debugBuffer = false;
        // /////////////////////////////////
        // Private/protected methods below
        // ///////////////////////////////
        /**
         * Set host
         *
         * @param {string} host
         */
        this._setHost = (host) => {
            // Validate host and port
            if (!host || host.length < 3) {
                throw new api_url_error_1.default(`[node-vmix] Invalid host provided '${host}'`);
            }
            this._host = host;
        };
        /**
         * Set port
         *
         * @param {number} port
         */
        this._setPort = (port) => {
            // Guard port number
            if (!port || port < 80 || port > 99999) {
                throw new api_url_error_1.default(`[node-vmix] Invalid port provided '${port}'`);
            }
            this._port = port;
        };
        /**
         * Process received data that is currently in the buffer
         */
        this._processBuffer = () => {
            // Process buffer if it contains data
            if (!this._buffer.byteLength) {
                return;
            }
            // Parse buffer to string and trim start and end
            const data = this._buffer.toString();
            // Split on each new line
            const receivedLines = data.split('\r\n');
            // If less than two lines were found
            // do not process buffer yet - keep whole buffer
            if (receivedLines.length === 0) {
                return;
            }
            // console.log('Total bytes length:', this.buffer.byteLength)
            // console.log('Got lines:', receivedLines.length)
            // console.log(receivedLines[0])
            // console.log(data.byteLength)
            // console.log('-----')
            // return
            // We know now that the buffer got at least one complete message!
            // We now ingest and analyse this first message
            let firstMsg = '';
            for (let i = 0; i < receivedLines.length; i++) {
                const line = receivedLines[i];
                if (line.length) {
                    firstMsg = line;
                    break;
                }
            }
            const firstMessage = firstMsg;
            if (firstMessage.length === 0) {
                return;
            }
            // Trim and then split the first message on spaces
            const firstMessageParts = firstMessage.split(' ')
                .map(p => p.trim())
                .filter(p => p);
            if (firstMessageParts.length < 2) {
                return;
            }
            const firstMessageLength = Buffer.from(firstMessage).byteLength;
            this._debugBuffer && console.log('[node-vmix] Reading buffer message:', firstMessage);
            // this._debugBuffers && console.log(
            //     'Length of first message in buffer',
            //     `"${firstMessage}"`,
            //     firstMessageLength,
            //     firstMessage.length
            // )
            const [messageType, messageStatus] = firstMessageParts;
            // If an XML message then
            // just emit the message without further manipulation
            if (messageType === 'XML') {
                return this._processBufferXMLmessage(firstMessage, firstMessageLength, firstMessageParts);
                // Otherwise treat customly based on type of message
            }
            return this._processBufferNonXMLmessage(messageType, messageStatus, firstMessage, firstMessageLength);
        };
        /**
         * Emit generic data message
         */
        this._emitMessage = (message) => {
            // Tap callback listeners with message
            this._listeners.data.forEach((cb) => {
                cb(message);
            });
        };
        /**
         * Emit Activators message
         */
        this.emitActivatorsMessage = (message) => {
            const listeners = this._listeners.activators;
            if (listeners.length) {
                // Tap callback listeners with tally summary
                listeners.forEach((cb) => {
                    cb(message);
                });
                return;
            }
            // If no activators-listeners were registered then
            // fallback to emit the message as generic message if enabled
            if (this._useDataListenersAsFallback) {
                return this._emitMessage(message);
            }
        };
        /**
         * Emit Tally message
         */
        this._emitTallyMessage = (message) => {
            const listeners = this._listeners.tally;
            if (listeners.length) {
                this._debug && console.log('Tally string: ', message);
                const tallyString = message
                    .replace('TALLY OK ', '');
                // Tap callback listeners with tally string
                listeners.forEach((cb) => {
                    cb(tallyString);
                });
                return;
            }
            // If no tally-listeners were registered then
            // fallback to emit the message as generic message if enabled
            if (this._useDataListenersAsFallback) {
                return this._emitMessage(message);
            }
        };
        /**
         * Emit Version message
         */
        this._emitVersionMessage = (message) => {
            const listeners = this._listeners.version;
            // If no version-listeners were registered then
            // fallback to emit the xml message as generic message
            if (listeners.length) {
                this._debug && console.log('Version message raw string: ', message);
                const versionString = message
                    .replace('VERSION OK ', '');
                // Tap callback listeners with tally summary
                listeners.forEach((cb) => {
                    cb(versionString);
                });
            }
            // If no version-listeners were registered then
            // fallback to emit the message as generic message if enabled
            if (this._useDataListenersAsFallback) {
                return this._emitMessage(message);
            }
        };
        /**
         * Emit XML message
         */
        this.emitXmlMessage = (message) => {
            const listeners = this._listeners.xml;
            // If no xmlData listeners were registered then
            // fallback to emit the xml message as generic message
            if (listeners.length) {
                // Tap callback listeners with message
                listeners.forEach((cb) => {
                    cb(message);
                });
            }
            // If no tally-listeners were registered then
            // fallback to emit the message as generic message if enabled
            if (this._useDataListenersAsFallback) {
                return this._emitMessage(message);
            }
        };
        /**
         * Convert a function command object to the string to execute
         *
         * @param {vMixApiFunctionCommand} command
         * @returns {string}
         */
        this.functionCommandObjectToString = (command) => {
            const cmdFunc = command.Function;
            // Clone command and remove function name from command object
            // The command is injected as querystring
            const cmd = command;
            delete cmd.Function;
            // Prepare output string builder
            const outputSB = ['FUNCTION', cmdFunc];
            // Turn other command parameters into querystring
            if (Object.values(command).length) {
                const cmdString = querystring_1.default.stringify(command);
                outputSB.push(cmdString);
            }
            const output = outputSB.join(' ');
            return output;
        };
        /**
         * Stringify commands
         * (if necessary)
         *
         * @param {vMixApiFunctionCommand|string} command
         * @returns {string}
         */
        this.stringifyCommand = (command) => {
            // If an object then it is a function command which
            // needs to be turned it into a valid string
            if (typeof command === 'object') {
                return this.functionCommandObjectToString(command);
            }
            // First word must be uppercase always
            // Get index of first space and upper case all characters until this index
            const indexFirstSpace = command.indexOf(' ');
            // If no spaces at all, just return upper cased word
            if (indexFirstSpace === -1) {
                return command.toUpperCase();
            }
            command = [
                // First word upper cased
                command.slice(0, indexFirstSpace + 1).toUpperCase(),
                // Rest of message
                command.slice(indexFirstSpace + 1),
            ].join('');
            // console.log('COMMAND', command)
            return command;
        };
        this.ensureMessageEnding = (message) => {
            // End message with a new line character
            // to make sure the message is interpreted by the receiver
            if (!message.endsWith('\r\n')) {
                message += '\r\n';
            }
            return message;
        };
        /**
         * Send message to connection
         *
         * This must be a string of the complete command to execute
         *
         * The available commands are listed under:
         * https://www.vmix.com/help23/TCPAPI.html
         * See "Commands section"
         *
         * @param {String} message
         * @returns {Promise}
         */
        this._sendMessageToSocket = async (message) => {
            this._debug && console.log('[node-vmix] Sending message to vMix instance via socket', message);
            // Guard connected
            if (!this.connected()) {
                this._debug && console.log('[node-vmix] Warning! Attempted to send message but socket is not connected');
                throw new Error('Not able to send message - not connected to socket yet!');
            }
            this._socket.write(message, (err) => {
                if (err)
                    throw err;
                // Resolve the promise since message has been written
                Promise.resolve();
            });
        };
        /**
         * Unregister all listeners
         */
        this.clearAllListeners = () => {
            // All available listener types
            const availableListenerTypes = SOCKET_BASE_LISTENER_TYPES.concat(CUSTOM_LISTENER_TYPES);
            // Iterate through all available listener type
            availableListenerTypes.forEach(listenerType => {
                // Unregister all listener by resetting array for each type of listener
                this._listeners[listenerType] = [];
            });
        };
        // Set debug flag if parsed in options - disabled as default
        if ('debug' in options && typeof options.debug === 'boolean' && options.debug) {
            this._debug = true;
        }
        // Set debug flag if parsed in options - disabled as default
        if ('debugBuffers' in options && typeof options.debugBuffers === 'boolean' && options.debugBuffers) {
            this._debugBuffer = true;
        }
        this._debug && console.log('[node-vmix] Instanciating TCP socket to vMix instance', host);
        this._debug && console.log('[node-vmix] Received host', host);
        this._debug && console.log('[node-vmix] Received options', options);
        this._debug && console.log('[node-vmix] -----');
        // Set core attributes
        this._setHost(host);
        this._setPort('port' in options && options.port ? options.port : DEFAULT_TCP_PORT);
        // Initialize listener arrays and callback taps
        // ... plus the generic ones from the socket!
        CUSTOM_LISTENER_TYPES.forEach((type) => {
            this._listeners[type] = [];
        });
        SOCKET_BASE_LISTENER_TYPES.forEach((type) => {
            this._listeners[type] = [];
        });
        // Setup socket base-listeners to tap all
        // registered callbacks
        SOCKET_BASE_LISTENER_TYPES.forEach((type) => {
            this._socket.on(type, (...data) => {
                // Notify all listeners of this type by
                // invoking callback-method (including data if present)
                this._listeners[type].forEach((cb) => {
                    cb(...data);
                });
            });
        });
        // Set autoReconnect option if in options - enabled as default
        if ('autoReconnect' in options && typeof options.autoReconnect === 'boolean') {
            this._autoReconnect = options.autoReconnect;
        }
        // Is onDataCallback passed in options in constructor?
        // Add this to listeners for data
        if ('onDataCallback' in options && typeof options.onDataCallback === 'function') {
            this._listeners.data.push(options.onDataCallback);
        }
        this._socket.on('connect', () => {
            this._debug && console.log('[node-vmix] Connected to vMix instance via TCP socket', this._host, this._port);
            this._isRetrying = false;
            // if (this._connectTimeout) {
            //     clearTimeout(this._connectTimeout)
            //     this._connectTimeout = null
            // }
            // Clear reconnection interval if it is set
            if (this._reconnectionInterval) {
                clearInterval(this._reconnectionInterval);
                this._reconnectionInterval = null;
            }
        });
        this._socket.on('close', () => {
            this._debug && console.log('[node-vmix] Socket connection closed');
            // if (this._connectTimeout) {
            //     clearTimeout(this._connectTimeout)
            //     this._connectTimeout = null
            // }
            // Check if auto reconnect is enabled
            // Otherwise also if already retrying, do not init further reconnect attempt
            if (!this._autoReconnect || this._isRetrying) {
                return;
            }
            this._isRetrying = true;
            this._debug && console.log('[node-vmix] Initialising reconnecting procedure...');
            // Each X try to reestablish connection to vMix instance
            this._reconnectionInterval = setInterval(() => {
                this.connect();
            }, this._reconnectionIntervalTimeout);
        });
        // On data listener
        // Put data into buffer and try to process data
        this._socket.on('data', (data) => {
            this._debugBuffer && console.log('[node-vmix] Received data from vMix instance via socket connection');
            this._debugBuffer && console.log(data);
            this._debugBuffer && console.log('----------------');
            this._buffer = Buffer.concat([this._buffer, data]);
            this._processBuffer();
        });
        // Setup timeout for maximum time to connect
        // this._connectTimeout = setTimeout(() => {
        //     this._debug && console.log('[node-vmix] Connect timeout reached')
        //     if (this._socket) {
        //         this._socket.destroy()
        //         this._socket = null
        //     }
        // }, this._connectTimeoutDuration)
        // Connect on initialization?
        // Enabled by default if not explicitly passed in options as a false value,
        // it is attempting to establish connection upon startup
        if (!('connectOnInitialization' in options)
            || (options.connectOnInitialization !== undefined
                && typeof options.connectOnInitialization === 'boolean'
                && options.connectOnInitialization)) {
            // Set a zero delay timeout to ensure that the caller can register
            // event handlers before we try to call them
            setTimeout(() => this.connect(), 0);
        }
    }
    _processBufferNonXMLmessage(messageType, messageStatus, firstMessage, firstMessageByteLength) {
        this._debugBuffer && console.log('[node-vmix] Processing non-XML message:', firstMessage);
        // If message status is Error then emit as regular message
        if (messageStatus === 'ER') {
            this._debugBuffer && console.log('[node-vmix] Emitting error message:', firstMessage);
            this._emitMessage(firstMessage);
        }
        else {
            const messageTypeLower = messageType.toLowerCase();
            this._debugBuffer && console.log('[node-vmix] Handling custom message:', messageType);
            switch (messageTypeLower) {
                case 'activators':
                    this.emitActivatorsMessage(firstMessage);
                    break;
                case 'tally':
                    // console.log('Not an XML message - instead a message of type', messageType)
                    this._emitTallyMessage(firstMessage);
                    break;
                case 'version':
                    // console.log('Not an XML message - instead a message of type', messageType)
                    this._emitVersionMessage(firstMessage);
                    break;
                default:
                    this._emitMessage(firstMessage);
                    break;
            }
        }
        // Pop first message from buffer
        const sliced = this._buffer.slice(firstMessageByteLength + NEWLINE_CHAR_BYTE_LENGTH);
        // console.log('Sliced', sliced.toString())
        this._buffer = sliced;
        this._processBuffer();
    }
    /**
     * Process buffer XML message
     *
     * @param firstMessage
     * @param firstMessageLength
     * @param firstMessageParts
     */
    _processBufferXMLmessage(firstMessage, firstMessageLength, firstMessageParts) {
        // We now know the message were a XML message
        if (firstMessageParts.length < 2) {
            this._debug && console.error('[node-vmix] First message did not include how long the XML should be..', firstMessage);
            return;
        }
        // What should the number of bytes the XML data should be?
        // The first message includes the length as the second argument
        // (e.g. "XML 2534")
        // The data could potentially be split up in multiple messages
        // Therefore, we need to check that we have received the complete
        // message, otherwise we do not emit the message yet!
        const bufferLengthNeeded = parseInt(firstMessageParts[1]);
        // console.log('Buffer Length needed', bufferLengthNeeded)
        // const dataMessages = data.slice(1) // Strip out the first message
        // const messages = dataMessages.join('\r\n') // Concat all received messages
        // Is the total length of the data "long enough"?
        // console.log('Buffer length: ', this.buffer.byteLength)
        // console.log('First message length: ', firstMessageLength)
        // console.log('Needed from message: ', bufferLengthNeeded)
        const messageCompleteLength = firstMessageLength + NEWLINE_CHAR_BYTE_LENGTH + bufferLengthNeeded;
        if (this._buffer.byteLength < messageCompleteLength) {
            // console.log('Not enough data in buffer...')
            // console.log(`"""${data}"""`)
            return;
        }
        // The buffer were "long enough"
        // Exctract the XML data
        const xmlData = this._buffer.slice(firstMessageLength + NEWLINE_CHAR_BYTE_LENGTH, firstMessageLength + bufferLengthNeeded);
        const xmlDataString = xmlData.toString();
        this.emitXmlMessage(xmlDataString);
        // Pop message from current buffer data and update buffer
        this._buffer = this._buffer.slice(messageCompleteLength);
        this._processBuffer();
    }
    // ///////////////////////////////
    // Protected/private methods end
    // /////////////////////////////
    // //////////////////////
    // Public methods start
    // ////////////////////
    /**
     * Connect
     *
     * Attempt to establish connection to socket of vMix instance
     */
    async connect(host, port) {
        this._debug && console.log(`[node-vmix] Attempting to establish TCP socket connection to vMix instance ${this._host}:${this._port}`);
        if (this.connected()) {
            this._debug && console.log(`[node-vmix] TCP socket connection to vMix instance was already established... ${this._host}:${this._port}`);
            return;
        }
        if (host) {
            this._setHost(host);
        }
        if (port) {
            this._setPort(port);
        }
        // Emit 'connecting'-event
        this._listeners.connecting.forEach(cb => cb());
        // Attempt establishing connection
        this._socket.connect(this._port, this._host, () => {
            // Resolve promise upon establishment of socket connection 
            Promise.resolve();
        });
    }
    /**
     * Send one or more messages to socket connection
     *
     * Messages are requests or command(s) to perform functions to the API
     *
     * This must be a string or object,
     * or a array of strings or objects (or a mix of object or strings)
     *
     * The available commands are listed under:
     * https://www.vmix.com/help24/TCPAPI.html
     * See "Commands section"
     *
     * @param {string|string[]|vMixApiFunctionCommand|vMixApiFunctionCommand[]} commands
     *
     */
    async send(command) {
        // Guard socket connected
        if (!this.connected()) {
            throw new Error('[node-vmix] Tried to send commands without open socket...');
        }
        const commands = !Array.isArray(command) ? [command] : command;
        // Stringify each command (if necessary) and send these as 
        // A concatenated message on TCP socket to vMix instance
        return this._sendMessageToSocket(commands
            .map(this.stringifyCommand)
            .map(this.ensureMessageEnding)
            .join(''));
    }
    /**
     * Register listener on a specific event type
     *
     * @param {string} type
     * @param {Function} callback
     */
    on(type, callback) {
        const desiredListenerType = type.toLowerCase();
        // All available listener types
        const availableListenerTypes = SOCKET_BASE_LISTENER_TYPES.concat(CUSTOM_LISTENER_TYPES);
        if (!availableListenerTypes.includes(desiredListenerType)) {
            throw new Error(`Invalid type of listener... '${type}'`);
        }
        this._listeners[desiredListenerType].push(callback);
    }
    /**
     * Unregister listeners of specific event-type and with a specific callback function-signature
     *
     * @param {string?} listenerType
     * @param {Function?} callbackSignature
     */
    off(listenerType, callbackSignature) {
        const desiredListenerType = listenerType.toLowerCase();
        // All available listener types
        const availableListenerTypes = SOCKET_BASE_LISTENER_TYPES.concat(CUSTOM_LISTENER_TYPES);
        if (!availableListenerTypes.includes(desiredListenerType)) {
            throw new Error(`Invalid type of listener... '${listenerType}'`);
        }
        // Remove listeners of specific callback method signature
        this._listeners[desiredListenerType] = this._listeners[desiredListenerType].filter((listener) => listener !== callbackSignature);
    }
    /**
     * Ask to Shutdown and destroy the TCP socket
     */
    shutdown() {
        // // Stop trying to reconnect after being instructed to shutdown.
        this._autoReconnect = false;
        if (this._reconnectionInterval) {
            clearInterval(this._reconnectionInterval);
            this._reconnectionInterval = null;
        }
        if (this.connected()) {
            // Gently close socket by sending QUIT message
            this.send('QUIT')
                .then(() => {
                this._socket.destroy();
            });
            return;
        }
        // Is not connected, so just destroy socket
        this._socket.destroy();
    }
    /**
     * Get "raw" TCP socket
     *
     * @returns Socket | null
     */
    socket() {
        return this._socket;
    }
    /**
     * Is currently connected?
     */
    connected() {
        // @ts-ignore
        return this._socket.readyState === 'open';
    }
    /**
     * Is currently connecting?
     */
    connecting() {
        // @ts-ignore
        return this._socket.readyState === 'opening';
    }
}
exports.ConnectionTCP = ConnectionTCP;
exports.default = ConnectionTCP;
//# sourceMappingURL=connection-tcp.js.map